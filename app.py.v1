#!/usr/bin/env python3
"""
Flask Network Ping Monitor
Simple backend to ping hosts and provide status API
"""

from flask import Flask, render_template, jsonify
import yaml
import subprocess
import platform
import time
import threading
from datetime import datetime
from typing import Dict, List, Optional
import logging

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = Flask(__name__)

class PingMonitor:
    def __init__(self, hosts_file='hosts.yaml'):
        self.hosts_file = hosts_file
        self.hosts = []
        self.results = {}
        self.load_hosts()
        
    def load_hosts(self):
        """Load hosts from YAML file"""
        try:
            with open(self.hosts_file, 'r') as f:
                data = yaml.safe_load(f)
                self.hosts = data.get('hosts', [])
                logger.info(f"Loaded {len(self.hosts)} hosts from {self.hosts_file}")
                
                # Initialize results
                for host in self.hosts:
                    self.results[host] = {
                        'status': 'unknown',
                        'latency': None,
                        'timestamp': None
                    }
        except Exception as e:
            logger.error(f"Error loading hosts file: {e}")
            self.hosts = []
    
    def ping_host(self, host: str) -> Dict:
        """Ping a single host and return result"""
        system = platform.system().lower()
        
        try:
            if system == 'windows':
                cmd = ['ping', '-n', '1', '-w', '5000', host]
            else:
                cmd = ['ping', '-c', '1', '-W', '5', host]
            
            start_time = time.time()
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)
            
            if result.returncode == 0:
                # Parse latency from output
                latency = self._parse_latency(result.stdout, system)
                
                # Determine status based on latency
                if latency is not None and latency <= 50:
                    status = 'green'
                elif latency is not None and latency > 50:
                    status = 'yellow'
                else:
                    status = 'green'  # Default if we can't parse latency but ping succeeded
                
                return {
                    'status': status,
                    'latency': latency,
                    'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                }
            else:
                return {
                    'status': 'red',
                    'latency': None,
                    'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                }
                
        except subprocess.TimeoutExpired:
            return {
                'status': 'red',
                'latency': None,
                'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            }
        except Exception as e:
            logger.error(f"Error pinging {host}: {e}")
            return {
                'status': 'red',
                'latency': None,
                'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            }
    
    def _parse_latency(self, output: str, system: str) -> Optional[float]:
        """Parse latency from ping output"""
        try:
            output_lower = output.lower()
            
            if system == 'windows':
                # Look for "time=XXXms" or "time<1ms"
                lines = output_lower.split('\n')
                for line in lines:
                    if 'time=' in line:
                        time_part = line.split('time=')[1].split()[0]
                        if 'ms' in time_part:
                            return float(time_part.replace('ms', ''))
                    elif 'time<' in line:
                        # Handle "time<1ms"
                        return 1.0
            else:
                # Linux/macOS: look for "time=XX.X ms"
                lines = output_lower.split('\n')
                for line in lines:
                    if 'time=' in line:
                        time_part = line.split('time=')[1].split()[0]
                        return float(time_part)
        except (IndexError, ValueError) as e:
            logger.debug(f"Could not parse latency from output: {e}")
        
        return None
    
    def ping_all_hosts(self):
        """Ping all hosts and update results"""
        for host in self.hosts:
            result = self.ping_host(host)
            self.results[host] = result
            logger.info(f"{host}: {result['status']} ({result['latency']}ms)")

# Initialize monitor
monitor = PingMonitor()

@app.route('/')
def index():
    """Serve the main page"""
    return render_template('index.html')

@app.route('/api/hosts')
def get_hosts():
    """Return list of all hosts"""
    return jsonify(monitor.hosts)

@app.route('/api/ping-all')
def ping_all():
    """Ping all hosts and return results"""
    monitor.ping_all_hosts()
    return jsonify(monitor.results)

@app.route('/api/ping/<host>')
def ping_single(host):
    """Ping a single host"""
    if host in monitor.hosts:
        result = monitor.ping_host(host)
        monitor.results[host] = result
        return jsonify({host: result})
    else:
        return jsonify({'error': 'Host not found'}), 404

@app.route('/api/status')
def get_status():
    """Get current status of all hosts"""
    return jsonify(monitor.results)

@app.route('/api/reload')
def reload_hosts():
    """Reload hosts from YAML file"""
    monitor.load_hosts()
    return jsonify({'message': f'Reloaded {len(monitor.hosts)} hosts'})

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=30500, debug=True)